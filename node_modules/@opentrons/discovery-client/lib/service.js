'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matchService = exports.DEFAULT_PORT = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
// create Services from different sources


exports.makeService = makeService;
exports.updateService = updateService;
exports.clearServiceIfConflict = clearServiceIfConflict;
exports.makeCandidate = makeCandidate;
exports.fromMdnsBrowser = fromMdnsBrowser;
exports.fromResponse = fromResponse;
exports.toCandidate = toCandidate;

var _net = require('net');

var _net2 = _interopRequireDefault(_net);

var _defaultTo = require('lodash/defaultTo');

var _defaultTo2 = _interopRequireDefault(_defaultTo);

var _isEqual = require('lodash/isEqual');

var _isEqual2 = _interopRequireDefault(_isEqual);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var nameExtractor = function nameExtractor(st) {
  return new RegExp('^(.+)\\._' + st.name + '\\._' + st.protocol);
};

var isLocal = function isLocal(ip) {
  if (ip == null) return null;
  return ip.startsWith('169.254') || ip.startsWith('[fe80') || ip.startsWith('[fd00') || ip === 'localhost';
};
var DEFAULT_PORT = exports.DEFAULT_PORT = 31950;

function makeService(name, ip, port, ok, serverOk, advertising, health, serverHealth) {
  return {
    name: name,
    ip: (0, _defaultTo2.default)(ip, null),
    port: (0, _defaultTo2.default)(port, DEFAULT_PORT),
    local: isLocal(ip),
    ok: (0, _defaultTo2.default)(ok, null),
    serverOk: (0, _defaultTo2.default)(serverOk, null),
    advertising: (0, _defaultTo2.default)(advertising, null),
    health: (0, _defaultTo2.default)(health, null),
    serverHealth: (0, _defaultTo2.default)(serverHealth, null)
  };
}

// apply known value updates (not null or undefined) to a service, returning
// original service reference if nothing to update
function updateService(service, update) {
  var next = update;

  return Object.keys(update).reduce(function (result, key) {
    var prevVal = result[key];
    var nextVal = (0, _defaultTo2.default)(next[key], prevVal);
    // use isEqual to deep compare response objects
    // $FlowFixMe: flow can't type [key]: nextVal but we know this is correct
    return (0, _isEqual2.default)(nextVal, prevVal) ? result : _extends({}, result, _defineProperty({}, key, nextVal));
  }, service);
}

// null out conflicting fields
function clearServiceIfConflict(service, update) {
  return update && service.ip === update.ip ? _extends({}, service, { ip: null, local: null, ok: null, serverOk: null }) : service;
}

function makeCandidate(ip, port) {
  return { ip: ip, port: port || DEFAULT_PORT };
}

function fromMdnsBrowser(browserService) {
  var addresses = browserService.addresses,
      type = browserService.type,
      port = browserService.port,
      fullname = browserService.fullname;


  if (!type || !fullname) return null;

  var ip = addresses.find(function (address) {
    return _net2.default.isIPv4(address);
  });
  if (!ip) ip = addresses.find(function (address) {
    return _net2.default.isIP(address);
  });
  if (!ip) return null;

  if (_net2.default.isIPv6(ip)) ip = '[' + ip + ']';

  var nameMatch = type[0] && fullname.match(nameExtractor(type[0]));
  var name = nameMatch && nameMatch[1] || fullname;

  return makeService(name, ip, port, null, null, true);
}

function fromResponse(candidate, healthResponse, serverHealthResponse) {
  var apiName = healthResponse && healthResponse.name;
  var serverName = serverHealthResponse && serverHealthResponse.name;
  var name = (0, _defaultTo2.default)(serverName, apiName);
  var apiOk = !!healthResponse;

  if (!name) return null;

  // in case of name mismatch, prefer /server/health name and flag not ok
  if (apiName != null && serverName != null && apiName !== serverName) {
    apiOk = false;
  }

  return makeService(name, candidate.ip, candidate.port, apiOk, !!serverHealthResponse, null, healthResponse, serverHealthResponse);
}

function toCandidate(service) {
  if (!service.ip) return null;

  return makeCandidate(service.ip, service.port);
}

var matchService = exports.matchService = function matchService(source) {
  return function (target) {
    return source.name === target.name && source.ip === target.ip;
  };
};