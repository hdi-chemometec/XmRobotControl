'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DiscoveryClient = exports.DEFAULT_PORT = exports.DEFAULT_DISCOVERY_INTERVAL = exports.DEFAULT_POLL_INTERVAL = exports.SERVICE_REMOVED_EVENT = exports.SERVICE_EVENT = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _types = require('./types');

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _types[key];
    }
  });
});
exports.default = DiscoveryClientFactory;

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _escapeStringRegexp = require('escape-string-regexp');

var _escapeStringRegexp2 = _interopRequireDefault(_escapeStringRegexp);

var _toRegex = require('to-regex');

var _toRegex2 = _interopRequireDefault(_toRegex);

var _differenceBy = require('lodash/differenceBy');

var _differenceBy2 = _interopRequireDefault(_differenceBy);

var _xorBy = require('lodash/xorBy');

var _xorBy2 = _interopRequireDefault(_xorBy);

var _mdnsBrowser = require('./mdns-browser');

var _mdnsBrowser2 = _interopRequireDefault(_mdnsBrowser);

var _poller = require('./poller');

var _serviceList = require('./service-list');

var _service = require('./service');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
// opentrons robot service discovery client
// finds robots on the network via mdns

var log = function log(logger, level, msg, meta) {
  return logger && typeof logger[level] === 'function' && logger[level](msg, meta);
};

var santizeRe = function santizeRe(patterns) {
  if (!patterns) return [];
  return patterns.map(function (p) {
    return typeof p === 'string' ? (0, _escapeStringRegexp2.default)(p) : p;
  });
};

function DiscoveryClientFactory(options) {
  return new DiscoveryClient(options || {});
}

var SERVICE_EVENT = exports.SERVICE_EVENT = 'service';
var SERVICE_REMOVED_EVENT = exports.SERVICE_REMOVED_EVENT = 'serviceRemoved';
var DEFAULT_POLL_INTERVAL = exports.DEFAULT_POLL_INTERVAL = 5000;
var DEFAULT_DISCOVERY_INTERVAL = exports.DEFAULT_DISCOVERY_INTERVAL = 90000;
exports.DEFAULT_PORT = _service.DEFAULT_PORT;


var TO_REGEX_OPTS = { contains: true, nocase: true, safe: true };

var DiscoveryClient = exports.DiscoveryClient = function (_EventEmitter) {
  _inherits(DiscoveryClient, _EventEmitter);

  function DiscoveryClient(options) {
    _classCallCheck(this, DiscoveryClient);

    // null out ok flag for pre-populated services
    var _this = _possibleConstructorReturn(this, (DiscoveryClient.__proto__ || Object.getPrototypeOf(DiscoveryClient)).call(this));

    _this.services = (0, _serviceList.createServiceList)(options.services || []);

    // allow strings instead of full {ip: string, port: ?number} object
    _this.candidates = (options.candidates || []).map(function (c) {
      return typeof c === 'string' ? (0, _service.makeCandidate)(c) : c;
    }).filter(function (c) {
      return _this.services.every(function (s) {
        return s.ip !== c.ip;
      });
    });

    _this._browser = null;
    _this._pollList = [];
    _this._pollInterval = options.pollInterval || DEFAULT_POLL_INTERVAL;
    _this._pollRequest = null;
    _this._nameFilter = (0, _toRegex2.default)(santizeRe(options.nameFilter), TO_REGEX_OPTS);
    _this._ipFilter = (0, _toRegex2.default)(santizeRe(options.ipFilter), TO_REGEX_OPTS);
    _this._portFilter = [_service.DEFAULT_PORT].concat(options.portFilter || []);
    _this._logger = options.logger;

    log(_this._logger, 'silly', 'Created', _this);
    return _this;
  }

  _createClass(DiscoveryClient, [{
    key: 'start',
    value: function start() {
      log(this._logger, 'debug', 'starting discovery client', {});
      this._startBrowser();
      this._poll();
      this._discoveryInterval = setInterval(this._rediscover.bind(this), DEFAULT_DISCOVERY_INTERVAL);

      return this;
    }
  }, {
    key: 'stop',
    value: function stop() {
      log(this._logger, 'debug', 'stopping discovery client', {});
      this._stopBrowser();
      this._stopPoll();
      clearInterval(this._discoveryInterval);

      return this;
    }
  }, {
    key: 'add',
    value: function add(ip, port) {
      if (!this.candidates.some(function (c) {
        return c.ip === ip;
      })) {
        var candidate = (0, _service.makeCandidate)(ip, port);
        log(this._logger, 'debug', 'adding new unique candidate', { candidate: candidate });
        this.candidates = this.candidates.concat(candidate);
        this._poll();
      }

      return this;
    }
  }, {
    key: 'remove',
    value: function remove(name) {
      var removals = this.services.filter(function (s) {
        return s.name === name;
      });

      this.services = this.services.filter(function (s) {
        return s.name !== name;
      });
      this.candidates = this.candidates.filter(function (c) {
        return removals.every(function (s) {
          return s.ip !== c.ip;
        });
      });

      log(this._logger, 'debug', 'removed services from discovery', { removals: removals });
      this._poll();
      this.emit(SERVICE_REMOVED_EVENT, removals);

      return this;
    }
  }, {
    key: 'setPollInterval',
    value: function setPollInterval(interval) {
      this._pollInterval = interval || DEFAULT_POLL_INTERVAL;
      this._poll(true);

      return this;
    }
  }, {
    key: '_poll',
    value: function _poll(forceRestart) {
      var nextPollList = this.services.map(_service.toCandidate).filter(Boolean).concat(this.candidates);

      // only poll if needed
      if (forceRestart || (0, _xorBy2.default)(this._pollList, nextPollList, 'ip').length) {
        log(this._logger, 'debug', '(re)starting polling', {});

        this._pollList = nextPollList;
        (0, _poller.stop)(this._pollRequest, this._logger);
        this._pollRequest = (0, _poller.poll)(nextPollList, this._pollInterval, this._handleHealth.bind(this), this._logger);
      }
    }
  }, {
    key: '_stopPoll',
    value: function _stopPoll() {
      (0, _poller.stop)(this._pollRequest, this._logger);
      this._pollRequest = null;
    }
  }, {
    key: '_startBrowser',
    value: function _startBrowser() {
      var _this2 = this;

      this._stopBrowser();

      var browser = (0, _mdnsBrowser2.default)().once('ready', function () {
        return browser.discover();
      }).on('update', function (service) {
        return _this2._handleUp(service);
      }).on('error', function (error) {
        return _this2.emit('error', error);
      });

      this._browser = browser;
    }
  }, {
    key: '_stopBrowser',
    value: function _stopBrowser() {
      if (this._browser) {
        this._browser.removeAllListeners('ready').removeAllListeners('update').removeAllListeners('error').stop();

        this._browser = null;
      }
    }
  }, {
    key: '_rediscover',
    value: function _rediscover() {
      var knownIps = (0, _mdnsBrowser.getKnownIps)(this._browser);
      log(this._logger, 'debug', 'refreshing advertising flags', { knownIps: knownIps });

      var nextServices = this.services.map(function (s) {
        return (0, _service.updateService)(s, {
          advertising: knownIps.includes(s.ip)
        });
      });

      this._updateLists(nextServices);
      this._stopBrowser();
      this._startBrowser();
    }
  }, {
    key: '_handleUp',
    value: function _handleUp(browserService) {
      log(this._logger, 'debug', 'mdns service detected', { browserService: browserService });
      var service = (0, _service.fromMdnsBrowser)(browserService);

      if (service) this._handleService(service);
    }
  }, {
    key: '_handleHealth',
    value: function _handleHealth(candidate, apiResponse, serverResponse) {
      var service = (0, _service.fromResponse)(candidate, apiResponse, serverResponse);

      if (service) return this._handleService(service);

      // else, response was not ok, so unset ok flag in all matching ips
      this._updateLists((0, _serviceList.updateServiceListByIp)(this.services, candidate.ip, {
        ok: false,
        serverOk: false
      }));
    }
  }, {
    key: '_handleService',
    value: function _handleService(service) {
      if (!this._nameFilter.test(service.name) || !this._ipFilter.test(service.ip || '') || !this._portFilter.includes(service.port)) {
        log(this._logger, 'debug', 'Ignoring service', service);
        return;
      }

      this._updateLists((0, _serviceList.upsertServiceList)(this.services, service));
    }

    // update this.services, emit if necessary, re-poll if necessary

  }, {
    key: '_updateLists',
    value: function _updateLists(nextServices) {
      var updated = (0, _differenceBy2.default)(nextServices, this.services);

      if (updated.length) {
        // $FlowFixMe: flow doesn't type differenceBy properly, but this works
        this.candidates = (0, _differenceBy2.default)(this.candidates, nextServices, 'ip');
        this.services = nextServices;
        this._poll();

        log(this._logger, 'debug', 'updated services', { updated: updated });
        this.emit(SERVICE_EVENT, updated);
      }
    }
  }]);

  return DiscoveryClient;
}(_events2.default);