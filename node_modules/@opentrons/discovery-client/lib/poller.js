'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
// poller that continuously hits /health of a list of IP ipAddresses

exports.poll = poll;
exports.stop = stop;

var _nodeFetch = require('node-fetch');

var _nodeFetch2 = _interopRequireDefault(_nodeFetch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MIN_SUBINTERVAL_MS = 100;
var MIN_TIMEOUT_MS = 30000;

function poll(candidates, interval, onHealth, log) {
  if (!candidates.length) return { id: null };

  log && log.debug('poller start', { interval: interval, candidates: candidates.length });

  var subInterval = Math.max(interval / candidates.length, MIN_SUBINTERVAL_MS);
  var timeout = Math.max(subInterval * candidates.length, MIN_TIMEOUT_MS);

  var id = setInterval(pollIp, subInterval);
  var request = { id: id };
  var current = -1;

  return request;

  function pollIp() {
    var next = getNextCandidate();

    fetchHealth(next, timeout, log).then(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          apiRes = _ref2[0],
          serverRes = _ref2[1];

      return onHealth(next, apiRes, serverRes);
    });
  }

  function getNextCandidate() {
    current += 1;

    if (current > candidates.length - 1) {
      current = 0;
    }

    return candidates[current];
  }
}

function stop(request, log) {
  var id = request && request.id;

  if (id) {
    clearInterval(id);
    log && log.debug('poller stop', { id: id });
  }
}

function fetchHealth(cand, timeout, log) {
  var apiHealthUrl = 'http://' + cand.ip + ':' + cand.port + '/health';
  var serverHealthUrl = 'http://' + cand.ip + ':' + cand.port + '/server/update/health';

  return Promise.all([fetchAndParseBody(apiHealthUrl, timeout, log), fetchAndParseBody(serverHealthUrl, timeout, log)]);
}

function fetchAndParseBody(url, timeout, log) {
  return (0, _nodeFetch2.default)(url, { timeout: timeout }).then(function (response) {
    return response.ok ? response.json() : null;
  }).then(function (body) {
    log && log.silly('GET', { url: url, body: body });
    return body;
  }).catch(function (error) {
    var message = error.message,
        type = error.type,
        code = error.code;

    log && log.silly('GET failed', { url: url, message: message, type: type, code: code });
    return null;
  });
}