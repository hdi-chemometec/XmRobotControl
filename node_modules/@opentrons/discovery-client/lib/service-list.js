'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.createServiceList = createServiceList;
exports.upsertServiceList = upsertServiceList;
exports.updateServiceListByIp = updateServiceListByIp;

var _differenceBy = require('lodash/differenceBy');

var _differenceBy2 = _interopRequireDefault(_differenceBy);

var _partition3 = require('lodash/partition');

var _partition4 = _interopRequireDefault(_partition3);

var _uniqBy = require('lodash/uniqBy');

var _uniqBy2 = _interopRequireDefault(_uniqBy);

var _service = require('./service');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createServiceList() {
  var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  // strip health flags from input list
  var nextList = list.map(function (s) {
    return (0, _service.makeService)(s.name, s.ip, s.port, null, null, null, s.health, s.serverHealth);
  });

  return dedupeServices(nextList);
}

function upsertServiceList(list, upsert) {
  var previous = list.find((0, _service.matchService)(upsert));
  var nextList = list;
  if (!previous) nextList = nextList.concat(upsert);

  nextList = nextList.map(function (service) {
    // don't do anything if this is the added entry
    if (service === upsert) return service;
    // else update previous entry if it exists
    if (service === previous) return (0, _service.updateService)(service, upsert);
    // else return the service, clearing flags if it conflicts with the update
    return (0, _service.clearServiceIfConflict)(service, upsert);
  });

  return dedupeServices(nextList);
}

function updateServiceListByIp(list, ip, update) {
  var nextList = list.map(function (service) {
    return service.ip === ip ? (0, _service.updateService)(service, update) : service;
  });

  return dedupeServices(nextList);
}

// ensure there aren't multiple entries with the same IP and there aren't
// multiple entries with the same name and ip: null
function dedupeServices(list) {
  var _partition = (0, _partition4.default)(list, 'ip'),
      _partition2 = _slicedToArray(_partition, 2),
      listWithIp = _partition2[0],
      listWithoutIp = _partition2[1];

  var sanitizedWithIp = listWithIp.reduce(function (result, service) {
    // we know IP exists here thanks to our partition above
    var ip = service.ip;
    var cleanedService = result.seenIps[ip] ? (0, _service.clearServiceIfConflict)(service, { ip: ip }) : service;

    result.seenIps[ip] = true;
    result.unique.push(cleanedService);

    return result;
  }, { unique: [], seenIps: {} }).unique;

  var dedupedWithoutIp = (0, _differenceBy2.default)((0, _uniqBy2.default)(listWithoutIp, 'name'), sanitizedWithIp, 'name');

  return sanitizedWithIp.concat(dedupedWithoutIp).sort(compareServices);
}

// sort service list by:
//   1. ip exists,
//   2. update server healthy
//   3. API healthy
//   4. link-local address
//   5. advertising
function compareServices(a, b) {
  if (a.ip && !b.ip) return -1;
  if (!a.ip && b.ip) return 1;
  if (a.serverOk && !b.serverOk) return -1;
  if (!a.serverOk && b.serverOk) return 1;
  if (a.ok && !b.ok) return -1;
  if (!a.ok && b.ok) return 1;
  if (a.local && !b.local) return -1;
  if (!a.local && b.local) return 1;
  if (a.advertising && !b.advertising) return -1;
  if (!a.advertising && b.advertising) return 1;
  return 0;
}